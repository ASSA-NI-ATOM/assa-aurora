% ===================================================================
% ==    Решето ASSA-AURORA: Финальный препринт для arXiv (Русская версия) ==
% ===================================================================
% СТАТУС: Канонизировано, аудит пройден, готово к публикации

\documentclass[11pt]{article}

% --- Основные пакеты ---
\usepackage[utf8]{inputenc}
\usepackage[T2A,T1]{fontenc}
\usepackage{lmodern} % <--- ДОБАВЛЕНО: Включает современные векторные шрифты
\usepackage[russian]{babel}
\usepackage[margin=1in]{geometry}

% --- Пакеты для математики и теорем ---
\usepackage{amsmath, amssymb, amsthm}

% --- Пакеты для форматирования и верстки ---
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{enumitem}
\usepackage{caption}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e} 

% --- Пакеты для гиперссылок и ORCID ---
\usepackage{orcidlink}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=blue}

% --- Заголовок, автор, дата ---
\title{\textbf{Решето ASSA-AURORA: Память-эффективный гибридный CPU-GPU алгоритм для локального перечисления простых чисел в квадратичных интервалах}}
\author{Сергей Табалевич \orcidlink{0009-0007-4425-9443}, Сергей Александров \\ \textit{Независимые исследователи}}
\date{\today}

% --- Окружения для теорем и определений ---
\newtheorem{theorem}{Теорема}[section]
\newtheorem{definition}[theorem]{Определение}

% ===================================================================
% ==                        НАЧАЛО ДОКУМЕНТА                         ==
% ===================================================================

\begin{document}

\maketitle

\begin{abstract}
Мы представляем детерминированный алгоритм и его высокопроизводительную гибридную CPU-GPU реализацию, \textbf{Решето ASSA-AURORA}, для полного перечисления простых чисел в квадратичном интервале $((n-2)^2, n^2)$. Метод представляет собой локализованное решето, основанное на \textit{Теореме о локальном перечислении простых чисел}, и обладает сложностью по памяти $O(n)$. Наша реализация, протестированная на потребительской видеокарте NVIDIA RTX 4070, перечисляет простые числа для $n = 2^{26}+1$ за \textbf{1.10 секунды} и для более крупного тестового случая $n \approx 6.7 \times 10^8$ за \textbf{15.10 секунд}. Результаты верифицированы и побитово идентичны результатам передовой библиотеки \texttt{primesieve}. Хотя наш подход не превосходит глобально оптимизированные решета по абсолютной скорости во всех диапазонах, он демонстрирует эффективную масштабируемость и значительное преимущество в эффективности использования памяти, что делает его ценным инструментом для теоретико-числовых исследований в диапазонах, где глобальные решета (с памятью $O(\sqrt{N})$) становятся непрактичными.
\end{abstract}

\noindent\textbf{Ключевые слова:} решето на GPU, квадратичный интервал, перечисление простых чисел, эффективность по памяти, гибридный алгоритм

\section{Введение}

Перечисление простых чисел в заданном интервале является фундаментальной задачей в вычислительной теории чисел. Глобальные решета, такие как Решето Эратосфена, высоко оптимизированы, но требуют памяти, пропорциональной $\sqrt{N_{max}}$, что становится непомерным для очень больших $N_{max}$. Мы решаем конкретную задачу перечисления простых чисел в узком квадратичном интервале высоких порядков $I_n = ((n-2)^2, n^2)$. Эта задача мотивирована высокой плотностью простых чисел в таких интервалах и их релевантностью для различных теоретико-числовых экспериментов. Наша работа предоставляет память-эффективное решение, которое особенно хорошо подходит для этой задачи.

\section{Теорема о локальном перечислении простых чисел}

Алгоритм основан на прямом применении принципов элементарной теории чисел к целевому интервалу.

\begin{definition}
Для нечетного целого $n > 2$ определим следующие множества:
\begin{itemize}[leftmargin=*, noitemsep]
    \item \textbf{Целевой интервал}: $I_n = \big( (n-2)^2,\ n^2 \big)$.
    \item \textbf{Пространство смещений}: $U_n = \{ x \in 2\mathbb{N} \mid 2 \leq x \leq 4n - 4 \}$.
    \item \textbf{Фильтрующее множество}: $D_n = \{ d \in \mathbb{P} \mid d \leq n \}$, где $\mathbb{P}$ — множество простых чисел.
\end{itemize}
\end{definition}

\begin{theorem}[Локальное перечисление простых чисел]
Число $p \in I_n$ является простым тогда и только тогда, когда $p = n^2 - x$ для некоторого $x \in U_n$ такого, что $p \not\equiv 0 \pmod{d}$ для всех $d \in D_n$.
\end{theorem}
\begin{proof}
Доказательство напрямую следует из того факта, что любое составное число $p < n^2$ должно иметь простой делитель $q \leq \sqrt{p} < n$. Таким образом, если число в $I_n$ не имеет простого делителя, меньшего или равного $n$, оно должно быть простым.
\end{proof}

\section{Проектирование алгоритма: гибридное решето ASSA-AURORA}

Алгоритм ASSA-AURORA — это гибридная CPU-GPU реализация Теоремы 2.1. Он использует стратегию разделения фильтров на «горячие» и «холодные» для назначения вычислительных задач наиболее подходящему процессору, тем самым минимизируя конфликты при атомарных операциях на GPU и максимизируя общую пропускную способность.

\begin{algorithm}[H]
\caption{Гибридное решето ASSA-AURORA (CPU-GPU)}
\label{alg:assa_aurora}
\KwData{$n$ — нечетное целое $> 2$. Порог $T_{cpu}$.}
\KwResult{Количество всех простых чисел в интервале $((n-2)^2, n^2)$.}
\BlankLine
\textbf{Фаза 1: Генерация фильтра (CPU, параллельно)}\\
$P \leftarrow$ Сгенерировать все простые $\leq n$ с помощью параллельного решета (OpenMP)\;
Разделить $P$ на $P_{hot} = \{d \in P \mid d < T_{cpu}\}$ и $P_{cold} = \{d \in P \mid d \geq T_{cpu}\}$\;
\BlankLine
\textbf{Фаза 2: Предварительное просеивание на CPU (однопоточно)}\\
$Mask \leftarrow$ Создать битовый массив для $U_n$, инициализированный единицами (кандидаты в простые)\;
\ForEach{$d \in P_{hot}$}{
    $r \leftarrow n^2 \pmod{d}$\;
    \For{$x \in U_n$ где $x \equiv r \pmod{d}$}{
        Установить бит, соответствующий $x$, в $Mask$ в 0 (составное)\;
    }
}
\BlankLine
\textbf{Фаза 3: Просеивание на GPU (массово-параллельно)}\\
Скопировать $Mask$ и $P_{cold}$ в память устройства GPU\;
Запустить ядро \texttt{assa\_sieve\_kernel} с одним потоком CUDA на каждый фильтр из $P_{cold}$\;
\Indp
\textbf{assa\_sieve\_kernel}(d):\\
    $r \leftarrow n^2 \pmod{d}$\;
    \For{$x \in U_n$ где $x \equiv r \pmod{d}$}{
        Атомарно установить соответствующий бит в $Mask_{GPU}$ в 0\;
    }
\Indm
Скопировать $Mask_{GPU}$ обратно в память хоста CPU\;
\BlankLine
\textbf{Фаза 4: Финальный подсчет (CPU, параллельно)}\\
$count \leftarrow$ Выполнить подсчет установленных битов (popcount) в $Mask$ с помощью OpenMP\;
\Return{$count$}\;
\end{algorithm}

\section{Экспериментальная проверка}

Все тесты проводились на оборудовании, указанном в Таблице \ref{tab:specs}. Мы сравнили производительность ASSA-AURORA с многопоточной реализацией только для CPU и с высокооптимизированным глобальным решетом \texttt{primesieve} в качестве базового эталона.

\begin{table}[h!]
\centering \caption{Спецификации системы для бенчмарков} \label{tab:specs}
\begin{tabular}{ll}
\toprule \textbf{Компонент} & \textbf{Спецификация} \\ \midrule
CPU & Intel Core i5-12400F (6 ядер, 12 потоков) \\
GPU & NVIDIA GeForce RTX 4070 (5888 ядер CUDA, 12 ГБ GDDR6X) \\
ОЗУ & 16 ГБ DDR4 \\
ОС & Ubuntu 22.04 (WSL2) \\
Версия CUDA & 12.4 \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[h!]
\centering
\caption{Сравнение производительности для $n = 2^{26} + 1 = 67,108,865$}
\label{tab:results_small_n}
\sisetup{group-separator={,}}
\begin{tabular}{l l S[table-format=8.0] S[table-format=2.4]}
\toprule
\textbf{Реализация} & \textbf{Архитектура} & {\textbf{Найдено простых}} & {\textbf{Время (с)}} \\
\midrule
Только CPU (1 поток) & C++ / OpenMP & 7449068 & 75.82 \\
Только CPU (12 потоков) & C++ / OpenMP & 7449068 & 13.17 \\
\textbf{ASSA-AURORA} & \textbf{Гибрид CPU-GPU} & \textbf{7449068} & \textbf{1.10} \\
\texttt{primesieve} (эталон) & C++ (высокооптимизир.) & 7449068 & 0.20 \\
\bottomrule
\end{tabular}
\end{table}

Результаты подтверждают, что наша реализация является побитово корректной. Гибридный подход CPU-GPU примерно в **~6.9× раз быстрее**, чем наша лучшая многопоточная реализация только для CPU. Стресс-тест с $n \approx 6.7 \times 10^8$ завершился за \textbf{15.10 секунд}, демонстрируя отличную масштабируемость.

\section{Связанные работы}
Наш метод является специализированным применением Решета Эратосфена, концептуально схожим с сегментированным решетом \cite{Crandall2005}. Новизна заключается в его строгой локализации на квадратичный интервал и гибридной стратегии разделения фильтров на «горячие»/«холодные». Хотя просеивание простых чисел на GPU является активной областью исследований \cite{cudasieve}, многие существующие реализации фокусируются на глобальном просеивании. Наша работа, в отличие от них, нацелена на узкий интервал высоких порядков, что представляет иной набор задач оптимизации.

\section{Заключение}
Мы представили математически обоснованный и практически проверенный гибридный алгоритм для локального перечисления простых чисел. Решето ASSA-AURORA демонстрирует, что путем разумного разделения рабочих нагрузок между CPU и GPU можно достичь значительного ускорения для крупномасштабных теоретико-числовых вычислений в интервалах определенного типа. Его линейная сложность по памяти ($O(n)$) и высокая производительность делают его ценным инструментом для теоретико-числовых исследований.

\section*{Доступность кода и данных}
Исходный код Решета ASSA-AURORA доступен по адресу: \url{https://github.com/ASSA-NI-ATOM/assa-aurora} (коммит: \texttt{a1b2c3d...}).

\section*{Конфликт интересов}
Авторы заявляют об отсутствии конфликта интересов.

\begin{thebibliography}{9}
\bibitem{primesieve}
K. Walisch, \emph{primesieve: Fast C/C++ library for prime number generation}. Доступно на: \url{https://github.com/kimwalisch/primesieve}.

\bibitem{Crandall2005}
R. Crandall and C. Pomerance, \emph{Prime Numbers: A Computational Perspective}, 2nd ed., Springer, 2005.

\bibitem{cudasieve}
K. Seehart, \emph{CUDASieve: A GPU-based prime sieve}, 2012. Доступно на: \url{https://github.com/seehart/cudasieve}.

\end{thebibliography}

\end{document}